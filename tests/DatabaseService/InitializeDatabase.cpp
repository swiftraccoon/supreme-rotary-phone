// Dependencies:
// https://github.com/catchorg/Catch2

// Generated by CodiumAI

TEST_CASE('DatabaseService::initializeDatabase') {


    // Initializes a database table named 'FileInfo' with columns 'id', 'file_name', 'transcription', 'tags', 'upload_status', and 'upload_path'
    SECTION('should initialize FileInfo table with correct columns') {
        // Arrange
        DatabaseService dbService("test.db");

        // Act
        dbService.initializeDatabase();

        // Assert
        sqlite3_stmt *stmt;
        const char *sqlSelect = "PRAGMA table_info(FileInfo);";
        REQUIRE(sqlite3_prepare_v2(dbService.db, sqlSelect, -1, &stmt, nullptr) == SQLITE_OK);

        std::vector<std::string> columns;
        while (sqlite3_step(stmt) == SQLITE_ROW) {
            const unsigned char *columnName = sqlite3_column_text(stmt, 1);
            columns.push_back(std::string(reinterpret_cast<const char *>(columnName)));
        }

        REQUIRE(columns.size() == 6);
        REQUIRE(columns[0] == "id");
        REQUIRE(columns[1] == "file_name");
        REQUIRE(columns[2] == "transcription");
        REQUIRE(columns[3] == "tags");
        REQUIRE(columns[4] == "upload_status");
        REQUIRE(columns[5] == "upload_path");

        sqlite3_finalize(stmt);
    }

    // Creates the 'FileInfo' table if it does not already exist
    SECTION('should create FileInfo table if it does not exist') {
        // Arrange
        DatabaseService dbService("test.db");

        // Act
        dbService.initializeDatabase();

        // Assert
        sqlite3_stmt *stmt;
        const char *sqlSelect = "SELECT name FROM sqlite_master WHERE type='table' AND name='FileInfo';";
        REQUIRE(sqlite3_prepare_v2(dbService.db, sqlSelect, -1, &stmt, nullptr) == SQLITE_OK);

        REQUIRE(sqlite3_step(stmt) == SQLITE_ROW);

        sqlite3_finalize(stmt);
    }

    // Returns no errors if the table creation is successful
    SECTION('should return no errors if table creation is successful') {
        // Arrange
        DatabaseService dbService("test.db");

        // Act & Assert
        REQUIRE_NOTHROW(dbService.initializeDatabase());
    }

    // Throws a runtime_error if the SQL execution fails
    SECTION('should throw runtime_error if SQL execution fails') {
        // Arrange
        DatabaseService dbService("test.db");

        // Act & Assert
        REQUIRE_THROWS_AS(dbService.initializeDatabase(), std::runtime_error);
    }

    // Throws a runtime_error if the SQL error message is unknown
    SECTION('should throw runtime_error if SQL error message is unknown') {
        // Arrange
        DatabaseService dbService("test.db");

        // Act & Assert
        REQUIRE_THROWS_WITH(dbService.initializeDatabase(), "SQL error: Unknown error");
    }

    // Throws a runtime_error if the statement preparation fails
    SECTION('should throw runtime_error if statement preparation fails') {
        // Arrange
        DatabaseService dbService("test.db");

        // Act & Assert
        REQUIRE_THROWS_AS(dbService.initializeDatabase(), std::runtime_error);
    }
}